# Section 3: 배열과 객체의 성능 평가

## 객체의 빅오(Big-O)

```javascript
let instructor = {
  firstName: "Kelly",
  isInstructor: true,
  favoritNumbers: [1, 2, 3, 4],
};
```

### 언제 객체를 쓸까?

1. 정렬이 필요없을 때
   - 객체에 시작과 끝이 없기 때문에 새로운 정보를 어디에 입력하든지 상관없다. 객체는 정보가 한 뭉치로 되어있다고 생각하면 된다.
2. 빠른 접근,입력과 제거가 필요할 때
   - 입력, 제거, 접근하는 시간이 상수 시간이다. &rarr; O(1)
   - 하지만 탐색은 O(n)이다. 키를 사용해 값을 찾는 것이기 때문에 모든 값을 전부 검사해야한다.

### 객체 메소드

1. Object.keys &rarr; O(n)
2. Object.values &rarr; O(n)
3. Object.entries &rarr; O(n)  
   &rarr; 위의 3개는 객체안에 값에 따라 결과의 양이 비례해서 변하므로 O(n)이다.

4. hasOwnProperty &rarr; O(1) 인자로 넘어간 키가 존재하는지 알려준다. 즉, 키에 접근해서 존재여부만 확인한다.

### 객체는 모든것을 빨리 처리한다. 하지만 정렬되어 있지 않다.

## 배열의 빅오(Big-O)

```javascript
let names = ["Michael", "Melissa", "Andrea"];
let values = [true, {}, [], 2, "awesome"];
```

- 배열안의 데이터 접근이 느린 이유
  - 배열의 가장 중요한 점은 정렬되어 있다는 점이다.

### 언제 배열을 쓸까?

1. 정렬된 데이터가 필요할 때
2. 데이터에 빠르게 접근할 때. &rarr; O(1)

10개의 요소를가진 배열이 있고 그 배열의 5번 인덱스의 값에 접근하고자 한다면 0번 부터하나씩 돌면서 5번 인덱스에 도착해  
그 값에 접근하는 것이 아니라 바로 5번 인덱스로 곧장 접근할 수 있다. 하지만 입력과 제거는 상황에 따라 다르다.  
정렬과 관련되었기 때문에 어디에 입력하고 제거하는지가 중요하다.

배열 맨 끝에다 요소를 추가(push)한다면 작업은 O(1)이 되지만 맨앞에 추가한다면 인덱스의 변화가 생긴다.  
요소 전부가 새로운 인덱스를 다시 부여받게 되기 때문에 O(n)이 된다. 제거하는 것도 똑같이 동작한다.  
&rarr; push와 pop이 shift와 unshift보다 빠르다. 접근은 위치에 상관없이 항상 빠르다.

대부분의 배열 메소드들은 O(n)의 시간 복잡도를 가지지만 sort 메소드는 다르다. &rarr; sort 메소드는 O(n\*log n)의 시간 복잡도를 가진다.  
정렬을 하기 위해선 요소를 비교하고 위치를 바꾸는 작업을 하게 되는데 이 과정에서 요소를 한번씩 보지 않는다.  
굉장히 복잡한 과정을 거치게 된다. &rarr; 굉장히 느리다.
